= The First Asciidoc example: Subtitle     
Lars Vogel(c) 2016 vogella GmbH                                     
Version 0.2, 17.12.2015                                             
:sectnums:                                                          
:toc:        left                                                   
:toclevels: 4                                                       
:toc-title: My Content                                              
                                                                    
:description: Example AsciiDoc document                             
:keywords: AsciiDoc                                                 
:imagesdir: ./img                                                   

This is the optional preamble (an untitled section body). Useful for
writing simple sectionless documents consisting only of a preamble.

== Modelo Del Dominio
[plantuml, draughtsModeloDominio, svg]
....
class Person {
+ name: string
+ surname: string;
+ birthday: string;
+ deadthDate: string;
+ description: string;
+ urlImage: string;
+ urlWiki: string
}

class Entity {
+ name: string
+ creationDate: string;
+ endDate: string;
+ description: string;
+ urlImage: string;
+ urlWiki: string
}

class Product {
+ name: string
+ creationDate: string;
+ endDate: string;
+ description: string;
+ urlImage: string;
+ urlWiki: string
}

class Category{
+ name: String
}

Product -down-> "*" Person
Product -down-> "*" Entity
Entity o-down-> "*" Person
Product --> "*" Category
Entity --> "*" Category
Person --> "*" Category
Category --> "*" Category

....

== Requisitos

=== Requisitos Funcionales

==== Actores y Casos de Uso
[plantuml, diagramaActoresCasosUso, svg]
....

left to right direction

actor User
usecase readIndex
usecase login
usecase logout
usecase register
usecase readEntity
usecase readPerson
usecase readProduct
usecase readTag


package writers {
actor Writer
usecase createEntity
usecase createPerson
usecase createProduct
usecase createTag
usecase updateEntity
usecase updatePerson
usecase updateProduct
usecase updateTag
usecase deleteEntity
usecase deletePerson
usecase deleteProduct
usecase deleteTag
usecase editEntity
usecase editPerson
usecase editProduct
usecase editTag
usecase asociateTag
}

User --> readIndex
User --> login
User --> logout
User --> register
User --> readPerson
User --> readEntity
User --> readProduct

readPerson ..> readIndex : <<include>>
readEntity ..> readIndex : <<include>>
readProduct ..> readIndex : <<include>>
readPerson ..> readTag : <<include>>
readEntity ..> readTag : <<include>>
readProduct ..> readTag: <<include>>

User <|-down- Writer
Writer --> createEntity
Writer --> createPerson
Writer --> createProduct
Writer --> createTag
Writer --> updateEntity
Writer --> updatePerson
Writer --> updateProduct
Writer --> updateTag
Writer --> deleteEntity
Writer --> deletePerson
Writer --> deleteProduct
Writer --> deleteTag
Writer --> asociateTag



createEntity ..> editPerson : <<include>>
createPerson ..> editEntity : <<include>>
createProduct ..> editProduct : <<include>>
createTag ..> editTag : <<include>>
updateEntity ..> editPerson : <<include>>
updatePerson ..> editEntity : <<include>>
updateProduct ..> editProduct : <<include>>
updateTag ..> editTag : <<include>>

editPerson ..> readIndex : <<include>>
editEntity ..> readIndex : <<include>>
editProduct ..> readIndex : <<include>>
editTag ..> readIndex : <<include>>


....

== Diagrama de contexto
[plantuml, contextDiagram, svg]
....

USER_NOT_LOGGED --> USER_LOGGED : login
USER_LOGGED --> USER_NOT_LOGGED : logout
USER_NOT_LOGGED --> USER_LOGGED : register
USER_LOGGED --> USER_LOGGED : create / delete / update
USER_NOT_LOGGED --> USER_NOT_LOGGED : read
USER_LOGGED -down-> [*]

....

== Diagramas de casos de uso
=== Login

[plantuml, loginUseCase, svg]
....


USER_NOT_LOGGED -down-> State1 : User request to login

state c <<choice>>

State1 --> State2 : Systems allows introduce email and password
State2 --> c : User introduce email and password
c -up-> USER_NOT_LOGGED : [email and password incorrect]
c --> USER_LOGGED : [email and password correct]

USER_LOGGED --> [*]

....

=== Logout

[plantuml, logoutUseCase, svg]
....
USER_LOGGED -down-> State1 : User request to logout

State1 --> USER_NOT_LOGGED : Systems allows to logout

USER_NOT_LOGGED --> [*]
....

=== Register

[plantuml, registerUseCase, svg]
....

[*] --> USER_NOT_LOGGED
USER_NOT_LOGGED -down-> State1 : User request to register 
State1 --> State2 : Systems allows to introduce name, surname, email and password


state c <<choice>>

State2 --> c : User introduce name, surname, email and password
c -up-> USER_NOT_LOGGED : [email exist]
c --> USER_LOGGED 
USER_LOGGED --> [*]


....

=== Person
==== Create Person

[plantuml, createPersonUseCase, svg]

....


USER_LOGGED_START --> State1 : User request to create a Person


note left of State1 : Use case of edit Person

State1 --> USER_LOGGED_END : Systems shows the created Person
USER_LOGGED_END --> [*]
....

==== Edit Person

[plantuml, editPersonUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to edit a Person
State1 --> State2 : System allows introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki and categoryList


state c <<choice>>
state d <<choice>>

State2 --> c :  User introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki 

c --> d : System allows introduce a categoryList
d --> State3 : [user select a Category]
d --> USER_LOGGED_END 
note left of State3 : Use case of asciate Category

State3 --> USER_LOGGED_END : Systems shows the edited Person
USER_LOGGED_END --> [*]
....

==== Update Person

[plantuml, updatePersonUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to update a Person
State1 -down-> State2 : System allows select the Person to update

state c <<choice>>

State2 -right-> c : User selects a Person to update

note left of State3 : Use case of edit Person

c --> State3
c-up-> State2 : [Person to update not found]

State3 --> USER_LOGGED_END : Systems shows the Person updated

USER_LOGGED_END --> [*]
....

==== Delete Person

[plantuml, deletePersonUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to delete a Person
State1 --> State2 : System allows select the Person to delete

state c <<choice>>


State2 --> c : User selects a Person to delete

c -up-> State2 : [Person to delete not found]
c --> State5
State5 --> USER_LOGGED_END : Systems shows the deleted person
USER_LOGGED_END --> [*]

....

=== Entity
==== Create Entity

[plantuml, createEntityUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to create a Entity
State1 --> State2 : User introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki and categoryList

note left of State2 : Use case of edit Entity

State2 --> USER_LOGGED_END : Systems shows the created Entity
USER_LOGGED_END --> [*]
....

==== Edit Entity

[plantuml, editEntityUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows edit a Entity
State1 --> State2 : User selects edit a Entity
State2 --> State3 : System allows introduce information about a Entity

state c <<choice>>

State3 --> c: User introduce information about a Entity

c --> State2 : [information invalid]
c--> State4
State4 --> USER_LOGGED_END : Systems shows the edited Entity
USER_LOGGED_END --> [*]
....

==== Update Entity

[plantuml, updateEntityUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows update a Entity
State1 --> State2 : User selects update a Entity
State2 -down-> State3 : System allows select the Entity to update

state c <<choice>>

State3 -right-> c : User selects a Entity to update

note left of State4 : Use case of edit Entity

c --> State4
c-up-> State2 : [Entity to update not found]

State4 --> USER_LOGGED_END : Systems shows the Entity updated

USER_LOGGED_END --> [*]
....

==== Delete Entity

[plantuml, deleteEntityUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows delete a Entity
State1 --> State2 : User selects delete a Entity
State2 --> State3 : System allows select the Entity to delete

state c <<choice>>


State3 --> c : User selects a Entity to delete

c -up-> State2 : [Entity to delete not found]
c --> State5
State5 --> USER_LOGGED_END : Systems shows the deleted Entity
USER_LOGGED_END --> [*]

....

=== Product
==== Create Product

[plantuml, createProductUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to create a Product
State1 --> State2 : User introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki and categoryListn

note left of State2 : Use case of edit Product

State2 --> USER_LOGGED_END : Systems shows the created Product
USER_LOGGED_END --> [*]
....


==== Edit Product

[plantuml, editProductUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows edit a Product
State1 --> State2 : User selects edit a Product
State2 --> State3 : System allows introduce information about a Product

state c <<choice>>

State3 --> c: User introduce information about a Product

c --> State2 : [information invalid]
c--> State4
State4 --> USER_LOGGED_END : Systems shows the edited Product
USER_LOGGED_END --> [*]
....

==== Update Product

[plantuml, updateProductUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows update a Product
State1 --> State2 : User selects update a Product
State2 -down-> State3 : System allows select the Product to update

state c <<choice>>

State3 -right-> c : User selects a Product to update

note left of State4 : Use case of edit Product

c --> State4
c-up-> State2 : [Product to update not found]

State4 --> USER_LOGGED_END : Systems shows the Product updated

USER_LOGGED_END --> [*]
....

==== Delete Product

[plantuml, deleteProductUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows delete a Product
State1 --> State2 : User selects delete a Product
State2 --> State3 : System allows select the Product to delete

state c <<choice>>


State3 --> c : User selects a Product to delete

c -up-> State2 : [Product to delete not found]
c --> State5
State5 --> USER_LOGGED_END : Systems shows the deleted Product
USER_LOGGED_END --> [*]

....

=== Category
==== Create Category

[plantuml, creat CategoryUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to create a Category
State1 --> State2 : Systems allows introduce name and Paren Category 

note left of State2 : Use case of edit Category
State2 -up-> State1 : [Paren Category not exist]
State2 --> USER_LOGGED_END : Systems shows the created Category
USER_LOGGED_END --> [*]
....


==== Delete Category

[plantuml, delet CategoryUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to delete a Category
State1 --> State2 : System allows to select a Category to delete


state c <<choice>>


State2 --> c : User select the Category to delete

c -up-> State2 :  Category to delete not found]
c --> State3
State3 --> USER_LOGGED_END : Systems shows the deleted Category
USER_LOGGED_END --> [*]

....

==== Asociate Category

[plantuml, asociateCategoryUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to asociate a Category
State1 --> State2: System allow to asociate a Category
State2--> State3: User select the Category to asociate
State4 --> State5: System allows select the Entity/Person/Product to ascociate
State5 --> State6: User select the Entity/Person/Product to asociate
State6 --> State7 : System shows the asociate Category

State7 --> USER_LOGGED_END
USER_LOGGED_END --> [*]

....

== Analisis

=== Diagrama de clases 
[plantuml, analysisClassDiagram, svg]
....

package "model"{
    class PersonModel {
+ name: String
+ birth: Date
+ death: Date
+ image: String
+ wiki: String 
}

class EntityModel {
+ name: String
+ creationDate: Date
+ wiki: String
}

class ProductModel {
+ name: String
+ creationDate: Date
+ wiki: String
}

class TagModel{
+ name: String
}

class UserModel{
+ email: String
+ password: String
}
}


ProductModel -down-> "*" PersonModel
ProductModel -down-> "*" EntityModel
EntityModel o-down-> "*" PersonModel
ProductModel --> "*" TagModel
EntityModel --> "*" TagModel
PersonModel --> "*" TagModel
TagModel --> "*" TagModel

package "controller"{

Class readEntityController
Class readPersonController
Class readProductController
Class readTagController

Class createEntityController
Class createPersonController
Class createProductController
Class createTagController
Class updateEntityController
Class updatePersonController
Class updateProductController
Class updateTagController
Class deleteEntityController
Class deletePersonController
Class deleteProductController
Class deleteTagController
Class editEntityController
Class editPersonController
Class editProductController
Class editTagController
Class asociateTagController
}

package "view" {

Class LoginView
Class RegisterView
Class HomeView
Class EntityView
Class PersonView
Class ProductView
Class EditEntityView
Class EditProductView
Class EditPersonView
Class DetailPersonView
Class DetailEntityView
Class DetailProductView



}

....
