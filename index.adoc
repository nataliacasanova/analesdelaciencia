= The First Asciidoc example: Subtitle     
Lars Vogel(c) 2016 vogella GmbH                                     
Version 0.2, 17.12.2015                                             
:sectnums:                                                          
:toc:        left                                                   
:toclevels: 4                                                       
:toc-title: My Content                                              
                                                                    
:description: Example AsciiDoc document                             
:keywords: AsciiDoc                                                 
:imagesdir: ./img                                                   

This is the optional preamble (an untitled section body). Useful for
writing simple sectionless documents consisting only of a preamble.

== Modelo Del Dominio
[plantuml, draughtsModeloDominio, svg]
....
class Person {
+ name: string
+ surname: string;
+ birthday: string;
+ deadthDate: string;
+ description: string;
+ urlImage: string;
+ urlWiki: string
}

class Entity {
+ name: string
+ creationDate: string;
+ endDate: string;
+ description: string;
+ urlImage: string;
+ urlWiki: string
}

class Product {
+ name: string
+ creationDate: string;
+ endDate: string;
+ description: string;
+ urlImage: string;
+ urlWiki: string
}

class Category{
+ name: String
}

Product -down-> "*" Person
Product -down-> "*" Entity
Entity o-down-> "*" Person
Product --> "*" Category
Entity --> "*" Category
Person --> "*" Category
Category --> "*" Category

....

== Requisitos

=== Requisitos Funcionales

==== Actores y Casos de Uso
[plantuml, diagramaActoresCasosUso, svg]
....

left to right direction

actor User
usecase readIndex
usecase login
usecase logout
usecase register
usecase readEntity
usecase readPerson
usecase readProduct
usecase readCategory


package writers {
actor Writer
usecase createEntity
usecase createPerson
usecase createProduct
usecase createCategory
usecase updateEntity
usecase updatePerson
usecase updateProduct
usecase updateCategory
usecase deleteEntity
usecase deletePerson
usecase deleteProduct
usecase deleteCategory
usecase editEntity
usecase editPerson
usecase editProduct
usecase editCategory
usecase asociateCategory
}

User --> readIndex
User --> login
User --> logout
User --> register
User --> readPerson
User --> readEntity
User --> readProduct

readPerson ..> readIndex : <<include>>
readEntity ..> readIndex : <<include>>
readProduct ..> readIndex : <<include>>
readPerson ..> readCategory : <<include>>
readEntity ..> readCategory : <<include>>
readProduct ..> readCategory: <<include>>

User <|-down- Writer
Writer --> createEntity
Writer --> createPerson
Writer --> createProduct
Writer --> createCategory
Writer --> updateEntity
Writer --> updatePerson
Writer --> updateProduct
Writer --> updateCategory
Writer --> deleteEntity
Writer --> deletePerson
Writer --> deleteProduct
Writer --> deleteCategory
Writer --> asociateCategory



createEntity ..> editPerson : <<include>>
createPerson ..> editEntity : <<include>>
createProduct ..> editProduct : <<include>>
createCategory ..> editCategory : <<include>>
updateEntity ..> editPerson : <<include>>
updatePerson ..> editEntity : <<include>>
updateProduct ..> editProduct : <<include>>
updateCategory ..> editCategory : <<include>>

editPerson ..> readIndex : <<include>>
editEntity ..> readIndex : <<include>>
editProduct ..> readIndex : <<include>>
editCategory ..> readIndex : <<include>>


....

== Diagrama de contexto
[plantuml, contextDiagram, svg]
....

USER_NOT_LOGGED --> USER_LOGGED : login
USER_LOGGED --> USER_NOT_LOGGED : logout
USER_NOT_LOGGED --> USER_LOGGED : register
USER_LOGGED --> USER_LOGGED : create / delete / update
USER_NOT_LOGGED --> USER_NOT_LOGGED : read
USER_LOGGED -down-> [*]

....

== Diagramas de casos de uso
=== Login

[plantuml, loginUseCase, svg]
....

state " " as State1
state " " as State2


USER_NOT_LOGGED -down-> State1 : User request to login

state c <<choice>>

State1 --> State2 : Systems allows introduce email and password
State2 --> c : User introduce email and password
c -up-> USER_NOT_LOGGED : [email and password incorrect]
c --> USER_LOGGED : [email and password correct]

USER_LOGGED --> [*]

....

=== Logout

[plantuml, logoutUseCase, svg]
....

state " " as State1

USER_LOGGED -down-> State1 : User request to logout

State1 --> USER_NOT_LOGGED : Systems allows to logout

USER_NOT_LOGGED --> [*]
....

=== Register

[plantuml, registerUseCase, svg]
....

state " " as State1
state " " as State2

USER_NOT_LOGGED -down-> State1 : User request to register 
State1 --> State2 : Systems allows to introduce name, surname, email and password


state c <<choice>>

State2 --> c : User introduce name, surname, email and password
c -up-> USER_NOT_LOGGED : [email exist]
c --> USER_LOGGED 
USER_LOGGED --> [*]


....

=== Person
==== Create Person

[plantuml, createPersonUseCase, svg]

....

state ":EditPersonSpecification" as State1
state "USER_LOGGED" as USER_LOGGED_START
state "USER_LOGGED" as USER_LOGGED_END

USER_LOGGED_START --> State1 : User request to create a Person


State1 --> USER_LOGGED_END : Systems shows the created Person
USER_LOGGED_END --> [*]
....

==== Edit Person

[plantuml, editPersonUseCase, svg]

....

state " " as State1
state " " as State2
state "USER_LOGGED" as USER_LOGGED_START
state " :AsociateCategorySpecification" as State3
state "USER_LOGGED" as USER_LOGGED_END

USER_LOGGED_START --> State1 : User request to edit a Person
State1 --> State2 : System allows introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki


state c <<choice>>
state d <<choice>>

State2 --> c :  User introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki 

c --> d : System allows introduce a categoryList
d --> State3 : [user select a Category]
d --> USER_LOGGED_END 


State3 --> USER_LOGGED_END : Systems shows the edited Person
USER_LOGGED_END --> [*]
....

==== Update Person

[plantuml, updatePersonUseCase, svg]

....
state " " as State1
state " " as State2
state "USER_LOGGED" as USER_LOGGED_START
state " :EditPersonSpecification " as State3
state "USER_LOGGED" as USER_LOGGED_END

USER_LOGGED_START --> State1 : User request to update a Person
State1 -down-> State2 : System allows select the Person to update

state c <<choice>>

State2 -right-> c : User selects a Person to update



c --> State3
c-up-> State2 : [Person to update not found]

State3 --> USER_LOGGED_END : Systems shows the Person updated

USER_LOGGED_END --> [*]
....

==== Delete Person

[plantuml, deletePersonUseCase, svg]

....

state " " as State1
state " " as State2
state "USER_LOGGED" as USER_LOGGED_START
state " " as State3
state "USER_LOGGED" as USER_LOGGED_END

USER_LOGGED_START --> State1 : User request to delete a Person
State1 --> State2 : System allows select the Person to delete

state c <<choice>>

State2 --> c : User selects a Person to delete

c -up-> State2 : [Person to delete not found]
c --> State3
State3 --> USER_LOGGED_END : Systems shows the deleted person
USER_LOGGED_END --> [*]

....

=== Entity
==== Create Entity

[plantuml, createEntityUseCase, svg]

....

state " " as State1
state ":EditEntitySpecification " as State2
state "USER_LOGGED" as USER_LOGGED_START
state "USER_LOGGED" as USER_LOGGED_END

USER_LOGGED_START --> State1 : User request to create a Entity
State1 --> State2 : User introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki and categoryList


State2 --> USER_LOGGED_END : Systems shows the created Entity
USER_LOGGED_END --> [*]
....

==== Edit Entity

[plantuml, editEntityUseCase, svg]

....

state " " as State1
state " " as State2
state " :AsociateCategorySpecification" as State3
state " :AsociateProductSpecification" as State4

state "USER_LOGGED" as USER_LOGGED_START
state "USER_LOGGED" as USER_LOGGED_END

USER_LOGGED_START --> State1 : User request edit a Entity
State1 --> State2 : System allows introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki, 


state c <<choice>>
state d <<choice>>

State2 --> c :  User introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki 

c --> d : System allows introduce categoryList and productList
d --> State3 : [user select a Category ]
d --> State4: [user select a Product]



State3 -->  USER_LOGGED_END  : Systems shows the edited Person
State4 -->  USER_LOGGED_END : Systems shows the edited Person
USER_LOGGED_END --> [*]
....

==== Update Entity

[plantuml, updateEntityUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows update a Entity
State1 --> State2 : User selects update a Entity
State2 -down-> State3 : System allows select the Entity to update

state c <<choice>>

State3 -right-> c : User selects a Entity to update

note left of State4 : Use case of edit Entity

c --> State4
c-up-> State2 : [Entity to update not found]

State4 --> USER_LOGGED_END : Systems shows the Entity updated

USER_LOGGED_END --> [*]
....

==== Delete Entity

[plantuml, deleteEntityUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows delete a Entity
State1 --> State2 : User selects delete a Entity
State2 --> State3 : System allows select the Entity to delete

state c <<choice>>


State3 --> c : User selects a Entity to delete

c -up-> State2 : [Entity to delete not found]
c --> State5
State5 --> USER_LOGGED_END : Systems shows the deleted Entity
USER_LOGGED_END --> [*]

....

=== Product
==== Create Product

[plantuml, createProductUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to create a Product
State1 --> State2 : User introduce name, surname, birthDate, deadthDate, description, urlImage, urlWiki and categoryListn

note left of State2 : Use case of edit Product

State2 --> USER_LOGGED_END : Systems shows the created Product
USER_LOGGED_END --> [*]
....


==== Edit Product

[plantuml, editProductUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows edit a Product
State1 --> State2 : User selects edit a Product
State2 --> State3 : System allows introduce information about a Product

state c <<choice>>

State3 --> c: User introduce information about a Product

c --> State2 : [information invalid]
c--> State4
State4 --> USER_LOGGED_END : Systems shows the edited Product
USER_LOGGED_END --> [*]
....

==== Update Product

[plantuml, updateProductUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows update a Product
State1 --> State2 : User selects update a Product
State2 -down-> State3 : System allows select the Product to update

state c <<choice>>

State3 -right-> c : User selects a Product to update

note left of State4 : Use case of edit Product

c --> State4
c-up-> State2 : [Product to update not found]

State4 --> USER_LOGGED_END : Systems shows the Product updated

USER_LOGGED_END --> [*]
....

==== Delete Product

[plantuml, deleteProductUseCase, svg]

....

USER_LOGGED_START --> State1 : Systems allows delete a Product
State1 --> State2 : User selects delete a Product
State2 --> State3 : System allows select the Product to delete

state c <<choice>>


State3 --> c : User selects a Product to delete

c -up-> State2 : [Product to delete not found]
c --> State5
State5 --> USER_LOGGED_END : Systems shows the deleted Product
USER_LOGGED_END --> [*]

....

=== Category
==== Create Category

[plantuml, creat CategoryUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to create a Category
State1 --> State2 : Systems allows introduce name and Paren Category 

note left of State2 : Use case of edit Category
State2 -up-> State1 : [Paren Category not exist]
State2 --> USER_LOGGED_END : Systems shows the created Category
USER_LOGGED_END --> [*]
....


==== Delete Category

[plantuml, delet CategoryUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to delete a Category
State1 --> State2 : System allows to select a Category to delete


state c <<choice>>


State2 --> c : User select the Category to delete

c -up-> State2 :  Category to delete not found]
c --> State3
State3 --> USER_LOGGED_END : Systems shows the deleted Category
USER_LOGGED_END --> [*]

....

==== Asociate Category

[plantuml, asociateCategoryUseCase, svg]

....

USER_LOGGED_START --> State1 : User request to asociate a Category
State1 --> State2: System allow to asociate a Category
State2--> State3: User select the Category to asociate
State4 --> State5: System allows select the Entity/Person/Product to ascociate
State5 --> State6: User select the Entity/Person/Product to asociate
State6 --> State7 : System shows the asociate Category

State7 --> USER_LOGGED_END
USER_LOGGED_END --> [*]

....

== Analisis

=== Diagrama de clases 
[plantuml, analysisClassDiagram, svg]
....

package "model"{
    class PersonModel {
+ name: String
+ birth: Date
+ death: Date
+ image: String
+ wiki: String 
}

class EntityModel {
+ name: String
+ creationDate: Date
+ wiki: String
}

class ProductModel {
+ name: String
+ creationDate: Date
+ wiki: String
}

class CategoryModel{
+ name: String
}

class UserModel{
+ email: String
+ password: String
}
}


ProductModel -down-> "*" PersonModel
ProductModel -down-> "*" EntityModel
EntityModel o-down-> "*" PersonModel
ProductModel --> "*" CategoryModel
EntityModel --> "*" CategoryModel
PersonModel --> "*" CategoryModel
CategoryModel --> "*" CategoryModel

package "controller"{

Class readEntityController
Class readPersonController
Class readProductController
Class readCategoryController

Class createEntityController
Class createPersonController
Class createProductController
Class createCategoryController
Class updateEntityController
Class updatePersonController
Class updateProductController
Class updateCategoryController
Class deleteEntityController
Class deletePersonController
Class deleteProductController
Class deleteCategoryController
Class editEntityController
Class editPersonController
Class editProductController
Class editCategoryController
Class asociateCategoryController
}

package "view" {

Class LoginView
Class RegisterView
Class HomeView
Class EntityView
Class PersonView
Class ProductView
Class EditEntityView
Class EditProductView
Class EditPersonView
Class DetailPersonView
Class DetailEntityView
Class DetailProductView



}

....
